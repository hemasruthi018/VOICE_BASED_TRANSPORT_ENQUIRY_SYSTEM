{"ast":null,"code":"\"use strict\";\n\n/**\r\n * Artyom.js is a voice control, speech recognition and speech synthesis JavaScript library.\r\n *\r\n * @requires {webkitSpeechRecognition && speechSynthesis}\r\n * @license MIT\r\n * @version 1.0.6\r\n * @copyright 2017 Our Code World (www.ourcodeworld.com) All Rights Reserved.\r\n * @author Carlos Delgado (https://github.com/sdkcarlos) and Sema García (https://github.com/semagarcia)\r\n * @see https://sdkcarlos.github.io/sites/artyom.html\r\n * @see http://docs.ourcodeworld.com/projects/artyom-js\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/// <reference path=\"artyom.d.ts\" />\n// Remove \"export default \" keywords if willing to build with `npm run artyom-build-window`\nvar Artyom = function () {\n  // Triggered at the declaration of \n  function Artyom() {\n    this.ArtyomCommands = [];\n    this.ArtyomVoicesIdentifiers = {\n      // German\n      \"de-DE\": [\"Google Deutsch\", \"de-DE\", \"de_DE\"],\n      // Spanish\n      \"es-ES\": [\"Google español\", \"es-ES\", \"es_ES\", \"es-MX\", \"es_MX\"],\n      // Italian\n      \"it-IT\": [\"Google italiano\", \"it-IT\", \"it_IT\"],\n      // Japanese\n      \"jp-JP\": [\"Google 日本人\", \"ja-JP\", \"ja_JP\"],\n      // English USA\n      \"en-US\": [\"Google US English\", \"en-US\", \"en_US\"],\n      // English UK\n      \"en-GB\": [\"Google UK English Male\", \"Google UK English Female\", \"en-GB\", \"en_GB\"],\n      // Brazilian Portuguese\n      \"pt-BR\": [\"Google português do Brasil\", \"pt-PT\", \"pt-BR\", \"pt_PT\", \"pt_BR\"],\n      // Portugal Portuguese\n      // Note: in desktop, there's no voice for portugal Portuguese\n      \"pt-PT\": [\"Google português do Brasil\", \"pt-PT\", \"pt_PT\"],\n      // Russian\n      \"ru-RU\": [\"Google русский\", \"ru-RU\", \"ru_RU\"],\n      // Dutch (holland)\n      \"nl-NL\": [\"Google Nederlands\", \"nl-NL\", \"nl_NL\"],\n      // French\n      \"fr-FR\": [\"Google français\", \"fr-FR\", \"fr_FR\"],\n      // Polish\n      \"pl-PL\": [\"Google polski\", \"pl-PL\", \"pl_PL\"],\n      // Indonesian\n      \"id-ID\": [\"Google Bahasa Indonesia\", \"id-ID\", \"id_ID\"],\n      // Hindi\n      \"hi-IN\": [\"Google हिन्दी\", \"hi-IN\", \"hi_IN\"],\n      // Mandarin Chinese\n      \"zh-CN\": [\"Google 普通话（中国大陆）\", \"zh-CN\", \"zh_CN\"],\n      // Cantonese Chinese\n      \"zh-HK\": [\"Google 粤語（香港）\", \"zh-HK\", \"zh_HK\"],\n      // Native voice\n      \"native\": [\"native\"]\n    };\n    // Important: retrieve the voices of the browser as soon as possible.\n    // Normally, the execution of speechSynthesis.getVoices will return at the first time an empty array.\n    if (window.hasOwnProperty('speechSynthesis')) {\n      speechSynthesis.getVoices();\n    } else {\n      console.error(\"Artyom.js can't speak without the Speech Synthesis API.\");\n    }\n    // This instance of webkitSpeechRecognition is the one used by Artyom.\n    if (window.hasOwnProperty('webkitSpeechRecognition')) {\n      this.ArtyomWebkitSpeechRecognition = new window.webkitSpeechRecognition();\n    } else {\n      console.error(\"Artyom.js can't recognize voice without the Speech Recognition API.\");\n    }\n    this.ArtyomProperties = {\n      lang: 'en-GB',\n      recognizing: false,\n      continuous: false,\n      speed: 1,\n      volume: 1,\n      listen: false,\n      mode: \"normal\",\n      debug: false,\n      helpers: {\n        redirectRecognizedTextOutput: null,\n        remoteProcessorHandler: null,\n        lastSay: null,\n        fatalityPromiseCallback: null\n      },\n      executionKeyword: null,\n      obeyKeyword: null,\n      speaking: false,\n      obeying: true,\n      soundex: false,\n      name: null\n    };\n    this.ArtyomGarbageCollection = [];\n    this.ArtyomFlags = {\n      restartRecognition: false\n    };\n    this.ArtyomGlobalEvents = {\n      ERROR: \"ERROR\",\n      SPEECH_SYNTHESIS_START: \"SPEECH_SYNTHESIS_START\",\n      SPEECH_SYNTHESIS_END: \"SPEECH_SYNTHESIS_END\",\n      TEXT_RECOGNIZED: \"TEXT_RECOGNIZED\",\n      COMMAND_RECOGNITION_START: \"COMMAND_RECOGNITION_START\",\n      COMMAND_RECOGNITION_END: \"COMMAND_RECOGNITION_END\",\n      COMMAND_MATCHED: \"COMMAND_MATCHED\",\n      NOT_COMMAND_MATCHED: \"NOT_COMMAND_MATCHED\"\n    };\n    this.Device = {\n      isMobile: false,\n      isChrome: true\n    };\n    if (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Windows Phone/i)) {\n      this.Device.isMobile = true;\n    }\n    if (navigator.userAgent.indexOf(\"Chrome\") == -1) {\n      this.Device.isChrome = false;\n    }\n    /**\r\n     * The default voice of Artyom in the Desktop. In mobile, you will need to initialize (or force the language)\r\n     * with a language code in order to find an available voice in the device, otherwise it will use the native voice.\r\n     */\n    this.ArtyomVoice = {\n      default: false,\n      lang: \"en-GB\",\n      localService: false,\n      name: \"Google UK English Male\",\n      voiceURI: \"Google UK English Male\"\n    };\n  }\n  /**\r\n   * Add dinamically commands to artyom using\r\n   * You can even add commands while artyom is active.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/addcommands\r\n   * @since 0.6\r\n   * @param {Object | Array[Objects]} param\r\n   * @returns {undefined}\r\n   */\n  Artyom.prototype.addCommands = function (param) {\n    var _this = this;\n    var processCommand = function (command) {\n      if (command.hasOwnProperty(\"indexes\")) {\n        _this.ArtyomCommands.push(command);\n      } else {\n        console.error(\"The given command doesn't provide any index to execute.\");\n      }\n    };\n    if (param instanceof Array) {\n      for (var i = 0; i < param.length; i++) {\n        processCommand(param[i]);\n      }\n    } else {\n      processCommand(param);\n    }\n    return true;\n  };\n  ;\n  /**\r\n   * The SpeechSynthesisUtterance objects are stored in the artyom_garbage_collector variable\r\n   * to prevent the wrong behaviour of artyom.say.\r\n   * Use this method to clear all spoken SpeechSynthesisUtterance unused objects.\r\n   *\r\n   * @returns {Array<any>}\r\n   */\n  Artyom.prototype.clearGarbageCollection = function () {\n    return this.ArtyomGarbageCollection = [];\n  };\n  ;\n  /**\r\n   * Displays a message in the console if the artyom propery DEBUG is set to true.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/debug\r\n   * @returns {undefined}\r\n   */\n  Artyom.prototype.debug = function (message, type) {\n    var preMessage = \"[v\" + this.getVersion() + \"] Artyom.js\";\n    if (this.ArtyomProperties.debug === true) {\n      switch (type) {\n        case \"error\":\n          console.log(\"%c\" + preMessage + \":%c \" + message, 'background: #C12127; color: black;', 'color:black;');\n          break;\n        case \"warn\":\n          console.warn(message);\n          break;\n        case \"info\":\n          console.log(\"%c\" + preMessage + \":%c \" + message, 'background: #4285F4; color: #FFFFFF', 'color:black;');\n          break;\n        default:\n          console.log(\"%c\" + preMessage + \":%c \" + message, 'background: #005454; color: #BFF8F8', 'color:black;');\n          break;\n      }\n    }\n  };\n  /**\r\n   * Artyom have it's own diagnostics.\r\n   * Run this function in order to detect why artyom is not initialized.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/detecterrors\r\n   * @param {type} callback\r\n   * @returns {}\r\n   */\n  Artyom.prototype.detectErrors = function () {\n    var _this = this;\n    if (window.location.protocol == \"file:\") {\n      var message = \"Error: running Artyom directly from a file. The APIs require a different communication protocol like HTTP or HTTPS\";\n      console.error(message);\n      return {\n        code: \"artyom_error_localfile\",\n        message: message\n      };\n    }\n    if (!_this.Device.isChrome) {\n      var message = \"Error: the Speech Recognition and Speech Synthesis APIs require the Google Chrome Browser to work.\";\n      console.error(message);\n      return {\n        code: \"artyom_error_browser_unsupported\",\n        message: message\n      };\n    }\n    if (window.location.protocol != \"https:\") {\n      console.warn(\"Warning: artyom is being executed using the '\" + window.location.protocol + \"' protocol. The continuous mode requires a secure protocol (HTTPS)\");\n    }\n    return false;\n  };\n  /**\r\n   * Removes all the added commands of artyom.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/emptycommands\r\n   * @since 0.6\r\n   * @returns {Array}\r\n   */\n  Artyom.prototype.emptyCommands = function () {\n    return this.ArtyomCommands = [];\n  };\n  /**\r\n   * Returns an object with data of the matched element\r\n   *\r\n   * @private\r\n   * @param {string} comando\r\n   * @returns {MatchedCommand}\r\n   */\n  Artyom.prototype.execute = function (voz) {\n    var _this = this;\n    if (!voz) {\n      console.warn(\"Internal error: Execution of empty command\");\n      return;\n    }\n    // If artyom was initialized with a name, verify that the name begins with it to allow the execution of commands.\n    if (_this.ArtyomProperties.name) {\n      if (voz.indexOf(_this.ArtyomProperties.name) != 0) {\n        _this.debug(\"Artyom requires with a name \\\"\" + _this.ArtyomProperties.name + \"\\\" but the name wasn't spoken.\", \"warn\");\n        return;\n      }\n      // Remove name from voice command\n      voz = voz.substr(_this.ArtyomProperties.name.length);\n    }\n    _this.debug(\">> \" + voz);\n    /** @3\r\n     * Artyom needs time to think that\r\n     */\n    for (var i = 0; i < _this.ArtyomCommands.length; i++) {\n      var instruction = _this.ArtyomCommands[i];\n      var opciones = instruction.indexes;\n      var encontrado = -1;\n      var wildy = \"\";\n      for (var c = 0; c < opciones.length; c++) {\n        var opcion = opciones[c];\n        if (!instruction.smart) {\n          continue; //Jump if is not smart command\n        }\n        // Process RegExp\n        if (opcion instanceof RegExp) {\n          // If RegExp matches \n          if (opcion.test(voz)) {\n            _this.debug(\">> REGEX \" + opcion.toString() + \" MATCHED AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\n            encontrado = parseInt(c.toString());\n          }\n          // Otherwise just wildcards\n        } else {\n          if (opcion.indexOf(\"*\") != -1) {\n            ///LOGIC HERE\n            var grupo = opcion.split(\"*\");\n            if (grupo.length > 2) {\n              console.warn(\"Artyom found a smart command with \" + (grupo.length - 1) + \" wildcards. Artyom only support 1 wildcard for each command. Sorry\");\n              continue;\n            }\n            //START SMART COMMAND\n            var before = grupo[0];\n            var later = grupo[1];\n            // Wildcard in the end\n            if (later == \"\" || later == \" \") {\n              if (voz.indexOf(before) != -1 || voz.toLowerCase().indexOf(before.toLowerCase()) != -1) {\n                wildy = voz.replace(before, '');\n                wildy = wildy.toLowerCase().replace(before.toLowerCase(), '');\n                encontrado = parseInt(c.toString());\n              }\n            } else {\n              if (voz.indexOf(before) != -1 || voz.toLowerCase().indexOf(before.toLowerCase()) != -1) {\n                if (voz.indexOf(later) != -1 || voz.toLowerCase().indexOf(later.toLowerCase()) != -1) {\n                  wildy = voz.replace(before, '').replace(later, '');\n                  wildy = wildy.toLowerCase().replace(before.toLowerCase(), '').replace(later.toLowerCase(), '');\n                  wildy = wildy.toLowerCase().replace(later.toLowerCase(), '');\n                  encontrado = parseInt(c.toString());\n                }\n              }\n            }\n          } else {\n            console.warn(\"Founded command marked as SMART but have no wildcard in the indexes, remove the SMART for prevent extensive memory consuming or add the wildcard *\");\n          }\n        }\n        if (encontrado >= 0) {\n          encontrado = parseInt(c.toString());\n          break;\n        }\n      }\n      if (encontrado >= 0) {\n        _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\n        var response = {\n          index: encontrado,\n          instruction: instruction,\n          wildcard: {\n            item: wildy,\n            full: voz\n          }\n        };\n        return response;\n      }\n    } //End @3\n    /** @1\r\n     * Search for IDENTICAL matches in the commands if nothing matches\r\n     * start with a index match in commands\r\n     */\n    for (var i = 0; i < _this.ArtyomCommands.length; i++) {\n      var instruction = _this.ArtyomCommands[i];\n      var opciones = instruction.indexes;\n      var encontrado = -1;\n      /**\r\n       * Execution of match with identical commands\r\n       */\n      for (var c = 0; c < opciones.length; c++) {\n        var opcion = opciones[c];\n        if (instruction.smart) {\n          continue; //Jump wildcard commands\n        }\n        if (voz === opcion) {\n          _this.debug(\">> MATCHED FULL EXACT OPTION \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\n          encontrado = parseInt(c.toString());\n          break;\n        } else if (voz.toLowerCase() === opcion.toLowerCase()) {\n          _this.debug(\">> MATCHED OPTION CHANGING ALL TO LOWERCASE \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\n          encontrado = parseInt(c.toString());\n          break;\n        }\n      }\n      if (encontrado >= 0) {\n        _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\n        var response = {\n          index: encontrado,\n          instruction: instruction\n        };\n        return response;\n      }\n    } //End @1\n    /**\r\n     * Step 3 Commands recognition.\r\n     * If the command is not smart, and any of the commands match exactly then try to find\r\n     * a command in all the quote.\r\n     */\n    for (var i = 0; i < _this.ArtyomCommands.length; i++) {\n      var instruction = _this.ArtyomCommands[i];\n      var opciones = instruction.indexes;\n      var encontrado = -1;\n      /**\r\n       * Execution of match with index\r\n       */\n      for (var c = 0; c < opciones.length; c++) {\n        if (instruction.smart) {\n          continue; //Jump wildcard commands\n        }\n        var opcion = opciones[c];\n        if (voz.indexOf(opcion) >= 0) {\n          _this.debug(\">> MATCHED INDEX EXACT OPTION \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\n          encontrado = parseInt(c.toString());\n          break;\n        } else if (voz.toLowerCase().indexOf(opcion.toLowerCase()) >= 0) {\n          _this.debug(\">> MATCHED INDEX OPTION CHANGING ALL TO LOWERCASE \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\n          encontrado = parseInt(c.toString());\n          break;\n        }\n      }\n      if (encontrado >= 0) {\n        _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\n        var response = {\n          index: encontrado,\n          instruction: instruction\n        };\n        return response;\n      }\n    } //End Step 3\n    /**\r\n     * If the soundex options is enabled, proceed to process the commands in case that any of the previous\r\n     * ways of processing (exact, lowercase and command in quote) didn't match anything.\r\n     * Based on the soundex algorithm match a command if the spoken text is similar to any of the artyom commands.\r\n     * Example :\r\n     * If you have a command with \"Open Wallmart\" and \"Open Willmar\" is recognized, the open wallmart command will be triggered.\r\n     * soundex(\"Open Wallmart\") == soundex(\"Open Willmar\") <= true\r\n     *\r\n     */\n    if (_this.ArtyomProperties.soundex) {\n      for (var i = 0; i < _this.ArtyomCommands.length; i++) {\n        var instruction = _this.ArtyomCommands[i];\n        var opciones = instruction.indexes;\n        var encontrado = -1;\n        for (var c = 0; c < opciones.length; c++) {\n          var opcion = opciones[c];\n          if (instruction.smart) {\n            continue; //Jump wildcard commands\n          }\n          if (_this.soundex(voz) == _this.soundex(opcion)) {\n            _this.debug(\">> Matched Soundex command '\" + opcion + \"' AGAINST '\" + voz + \"' with index \" + c, \"info\");\n            encontrado = parseInt(c.toString());\n            _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\n            var response = {\n              index: encontrado,\n              instruction: instruction\n            };\n            return response;\n          }\n        }\n      }\n    }\n    _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.NOT_COMMAND_MATCHED);\n    _this.triggerEvent(_this.ArtyomGlobalEvents.NOT_COMMAND_MATCHED);\n    return;\n  };\n  /**\r\n   * Force artyom to stop listen even if is in continuos mode.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/fatality\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.fatality = function () {\n    var _this = this;\n    //fatalityPromiseCallback\n    return new Promise(function (resolve, reject) {\n      // Expose the fatality promise callback to the helpers object of Artyom.\n      // The promise isn't resolved here itself but in the onend callback of\n      // the speechRecognition instance of artyom\n      _this.ArtyomProperties.helpers.fatalityPromiseCallback = resolve;\n      try {\n        // If config is continuous mode, deactivate anyway.\n        _this.ArtyomFlags.restartRecognition = false;\n        _this.ArtyomWebkitSpeechRecognition.stop();\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  /**\r\n   * Returns an array with all the available commands for artyom.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getavailablecommands\r\n   * @readonly\r\n   * @returns {Array}\r\n   */\n  Artyom.prototype.getAvailableCommands = function () {\n    return this.ArtyomCommands;\n  };\n  /**\r\n   * Artyom can return inmediately the voices available in your browser.\r\n   *\r\n   * @readonly\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getvoices\r\n   * @returns {Array}\r\n   */\n  Artyom.prototype.getVoices = function () {\n    return window.speechSynthesis.getVoices();\n  };\n  /**\r\n   * Verify if the browser supports speechSynthesis.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/speechsupported\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.speechSupported = function () {\n    return 'speechSynthesis' in window;\n  };\n  /**\r\n   * Verify if the browser supports webkitSpeechRecognition.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/recognizingsupported\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.recognizingSupported = function () {\n    return 'webkitSpeechRecognition' in window;\n  };\n  /**\r\n   * Stops the actual and pendings messages that artyom have to say.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/shutup\r\n   * @returns {undefined}\r\n   */\n  Artyom.prototype.shutUp = function () {\n    if ('speechSynthesis' in window) {\n      do {\n        window.speechSynthesis.cancel();\n      } while (window.speechSynthesis.pending === true);\n    }\n    this.ArtyomProperties.speaking = false;\n    this.clearGarbageCollection();\n  };\n  /**\r\n   * Returns an object with the actual properties of artyom.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getproperties\r\n   * @returns {object}\r\n   */\n  Artyom.prototype.getProperties = function () {\n    return this.ArtyomProperties;\n  };\n  /**\r\n   * Returns the code language of artyom according to initialize function.\r\n   * if initialize not used returns english GB.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getlanguage\r\n   * @returns {String}\r\n   */\n  Artyom.prototype.getLanguage = function () {\n    return this.ArtyomProperties.lang;\n  };\n  /**\r\n   * Retrieves the used version of Artyom.js\r\n   *\r\n   * @returns {String}\r\n   */\n  Artyom.prototype.getVersion = function () {\n    return '1.0.6';\n  };\n  /**\r\n   * Artyom awaits for orders when this function\r\n   * is executed.\r\n   *\r\n   * If artyom gets a first parameter the instance will be stopped.\r\n   *\r\n   * @private\r\n   * @returns {undefined}\r\n   */\n  Artyom.prototype.hey = function (resolve, reject) {\n    var start_timestamp;\n    var artyom_is_allowed;\n    var _this = this;\n    /**\r\n     * On mobile devices the recognized text is always thrown twice.\r\n     * By setting the following configuration, fixes the issue\r\n     */\n    if (this.Device.isMobile) {\n      this.ArtyomWebkitSpeechRecognition.continuous = false;\n      this.ArtyomWebkitSpeechRecognition.interimResults = false;\n      this.ArtyomWebkitSpeechRecognition.maxAlternatives = 1;\n    } else {\n      this.ArtyomWebkitSpeechRecognition.continuous = true;\n      this.ArtyomWebkitSpeechRecognition.interimResults = true;\n    }\n    this.ArtyomWebkitSpeechRecognition.lang = this.ArtyomProperties.lang;\n    this.ArtyomWebkitSpeechRecognition.onstart = function () {\n      _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.COMMAND_RECOGNITION_START);\n      _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_START);\n      _this.ArtyomProperties.recognizing = true;\n      artyom_is_allowed = true;\n      resolve();\n    };\n    /**\r\n     * Handle all artyom posible exceptions\r\n     *\r\n     * @param {type} event\r\n     * @returns {undefined}\r\n     */\n    this.ArtyomWebkitSpeechRecognition.onerror = function (event) {\n      // Reject promise on initialization\n      reject(event.error);\n      // Dispath error globally (artyom.when)\n      _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\n        code: event.error\n      });\n      if (event.error == 'audio-capture') {\n        artyom_is_allowed = false;\n      }\n      if (event.error == 'not-allowed') {\n        artyom_is_allowed = false;\n        if (event.timeStamp - start_timestamp < 100) {\n          _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\n            code: \"info-blocked\",\n            message: \"Artyom needs the permision of the microphone, is blocked.\"\n          });\n        } else {\n          _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\n            code: \"info-denied\",\n            message: \"Artyom needs the permision of the microphone, is denied\"\n          });\n        }\n      }\n    };\n    /**\r\n     * Check if continuous mode is active and restart the recognition.\r\n     * Throw events too.\r\n     *\r\n     * @returns {undefined}\r\n     */\n    _this.ArtyomWebkitSpeechRecognition.onend = function () {\n      if (_this.ArtyomFlags.restartRecognition === true) {\n        if (artyom_is_allowed === true) {\n          _this.ArtyomWebkitSpeechRecognition.start();\n          _this.debug(\"Continuous mode enabled, restarting\", \"info\");\n        } else {\n          console.error(\"Verify the microphone and check for the table of errors in sdkcarlos.github.io/sites/artyom.html to solve your problem. If you want to give your user a message when an error appears add an artyom listener\");\n        }\n        _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END, {\n          code: \"continuous_mode_enabled\",\n          message: \"OnEnd event reached with continuous mode\"\n        });\n      } else {\n        // If the fatality promise callback was set, invoke it\n        if (_this.ArtyomProperties.helpers.fatalityPromiseCallback) {\n          // As the speech recognition doesn't finish really, wait 500ms\n          // to trigger the real fatality callback\n          setTimeout(function () {\n            _this.ArtyomProperties.helpers.fatalityPromiseCallback();\n          }, 500);\n          _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END, {\n            code: \"continuous_mode_disabled\",\n            message: \"OnEnd event reached without continuous mode\"\n          });\n        }\n      }\n      _this.ArtyomProperties.recognizing = false;\n    };\n    /**\r\n     * Declare the processor dinamycally according to the mode of artyom\r\n     * to increase the performance.\r\n     *\r\n     * @type {Function}\r\n     * @return\r\n     */\n    var onResultProcessor;\n    // Process the recognition in normal mode\n    if (_this.ArtyomProperties.mode == \"normal\") {\n      onResultProcessor = function (event) {\n        if (!_this.ArtyomCommands.length) {\n          _this.debug(\"No commands to process in normal mode.\");\n          return;\n        }\n        var cantidadResultados = event.results.length;\n        _this.triggerEvent(_this.ArtyomGlobalEvents.TEXT_RECOGNIZED);\n        for (var i = event.resultIndex; i < cantidadResultados; ++i) {\n          var identificated = event.results[i][0].transcript;\n          if (event.results[i].isFinal) {\n            var comando = _this.execute(identificated.trim());\n            // Redirect the output of the text if necessary\n            if (typeof _this.ArtyomProperties.helpers.redirectRecognizedTextOutput === \"function\") {\n              _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, true);\n            }\n            if (comando && _this.ArtyomProperties.recognizing == true) {\n              _this.debug(\"<< Executing Matching Recognition in normal mode >>\", \"info\");\n              _this.ArtyomWebkitSpeechRecognition.stop();\n              _this.ArtyomProperties.recognizing = false;\n              // Execute the command if smart\n              if (comando.wildcard) {\n                comando.instruction.action(comando.index, comando.wildcard.item, comando.wildcard.full);\n                // Execute a normal command\n              } else {\n                comando.instruction.action(comando.index);\n              }\n              break;\n            }\n          } else {\n            // Redirect output when necesary\n            if (typeof _this.ArtyomProperties.helpers.redirectRecognizedTextOutput === \"function\") {\n              _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, false);\n            }\n            if (typeof _this.ArtyomProperties.executionKeyword === \"string\") {\n              if (identificated.indexOf(_this.ArtyomProperties.executionKeyword) != -1) {\n                var comando = _this.execute(identificated.replace(_this.ArtyomProperties.executionKeyword, '').trim());\n                if (comando && _this.ArtyomProperties.recognizing == true) {\n                  _this.debug(\"<< Executing command ordered by ExecutionKeyword >>\", 'info');\n                  _this.ArtyomWebkitSpeechRecognition.stop();\n                  _this.ArtyomProperties.recognizing = false;\n                  //Executing Command Action\n                  if (comando.wildcard) {\n                    comando.instruction.action(comando.index, comando.wildcard.item, comando.wildcard.full);\n                  } else {\n                    comando.instruction.action(comando.index);\n                  }\n                  break;\n                }\n              }\n            }\n            _this.debug(\"Normal mode : \" + identificated);\n          }\n        }\n      };\n    }\n    // Process the recognition in quick mode\n    if (_this.ArtyomProperties.mode == \"quick\") {\n      onResultProcessor = function (event) {\n        if (!_this.ArtyomCommands.length) {\n          _this.debug(\"No commands to process.\");\n          return;\n        }\n        var cantidadResultados = event.results.length;\n        _this.triggerEvent(_this.ArtyomGlobalEvents.TEXT_RECOGNIZED);\n        for (var i = event.resultIndex; i < cantidadResultados; ++i) {\n          var identificated = event.results[i][0].transcript;\n          if (!event.results[i].isFinal) {\n            var comando = _this.execute(identificated.trim());\n            //Redirect output when necesary\n            if (typeof _this.ArtyomProperties.helpers.redirectRecognizedTextOutput === \"function\") {\n              _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, true);\n            }\n            if (comando && _this.ArtyomProperties.recognizing == true) {\n              _this.debug(\"<< Executing Matching Recognition in quick mode >>\", \"info\");\n              _this.ArtyomWebkitSpeechRecognition.stop();\n              _this.ArtyomProperties.recognizing = false;\n              //Executing Command Action\n              if (comando.wildcard) {\n                comando.instruction.action(comando.index, comando.wildcard.item);\n              } else {\n                comando.instruction.action(comando.index);\n              }\n              break;\n            }\n          } else {\n            var comando = _this.execute(identificated.trim());\n            //Redirect output when necesary\n            if (typeof _this.ArtyomProperties.helpers.redirectRecognizedTextOutput === \"function\") {\n              _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, false);\n            }\n            if (comando && _this.ArtyomProperties.recognizing == true) {\n              _this.debug(\"<< Executing Matching Recognition in quick mode >>\", \"info\");\n              _this.ArtyomWebkitSpeechRecognition.stop();\n              _this.ArtyomProperties.recognizing = false;\n              //Executing Command Action\n              if (comando.wildcard) {\n                comando.instruction.action(comando.index, comando.wildcard.item);\n              } else {\n                comando.instruction.action(comando.index);\n              }\n              break;\n            }\n          }\n          _this.debug(\"Quick mode : \" + identificated);\n        }\n      };\n    }\n    // Process the recognition in remote mode\n    if (_this.ArtyomProperties.mode == \"remote\") {\n      onResultProcessor = function (event) {\n        var cantidadResultados = event.results.length;\n        _this.triggerEvent(_this.ArtyomGlobalEvents.TEXT_RECOGNIZED);\n        if (typeof _this.ArtyomProperties.helpers.remoteProcessorHandler !== \"function\") {\n          return _this.debug(\"The remoteProcessorService is undefined.\", \"warn\");\n        }\n        for (var i = event.resultIndex; i < cantidadResultados; ++i) {\n          var identificated = event.results[i][0].transcript;\n          _this.ArtyomProperties.helpers.remoteProcessorHandler({\n            text: identificated,\n            isFinal: event.results[i].isFinal\n          });\n        }\n      };\n    }\n    /**\r\n     * Process the recognition event with the previously\r\n     * declared processor function.\r\n     *\r\n     * @param {type} event\r\n     * @returns {undefined}\r\n     */\n    _this.ArtyomWebkitSpeechRecognition.onresult = function (event) {\n      if (_this.ArtyomProperties.obeying) {\n        onResultProcessor(event);\n      } else {\n        // Handle obeyKeyword if exists and artyom is not obeying\n        if (!_this.ArtyomProperties.obeyKeyword) {\n          return;\n        }\n        var temporal = \"\";\n        var interim = \"\";\n        for (var i = 0; i < event.results.length; ++i) {\n          if (event.results[i].isFinal) {\n            temporal += event.results[i][0].transcript;\n          } else {\n            interim += event.results[i][0].transcript;\n          }\n        }\n        _this.debug(\"Artyom is not obeying\", \"warn\");\n        // If the obeyKeyword is found in the recognized text\n        // enable command recognition again\n        if (interim.indexOf(_this.ArtyomProperties.obeyKeyword) > -1 || temporal.indexOf(_this.ArtyomProperties.obeyKeyword) > -1) {\n          _this.ArtyomProperties.obeying = true;\n        }\n      }\n    };\n    if (_this.ArtyomProperties.recognizing) {\n      _this.ArtyomWebkitSpeechRecognition.stop();\n      _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END);\n      _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END);\n    } else {\n      try {\n        _this.ArtyomWebkitSpeechRecognition.start();\n      } catch (e) {\n        _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\n          code: \"recognition_overlap\",\n          message: \"A webkitSpeechRecognition instance has been started while there's already running. Is recommendable to restart the Browser\"\n        });\n      }\n    }\n  };\n  /**\r\n   * Set up artyom for the application.\r\n   *\r\n   * This function will set the default language used by artyom\r\n   * or notice the user if artyom is not supported in the actual\r\n   * browser\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/initialize\r\n   * @param {Object} config\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.initialize = function (config) {\n    var _this = this;\n    if (typeof config !== \"object\") {\n      return Promise.reject(\"You must give the configuration for start artyom properly.\");\n    }\n    if (config.hasOwnProperty(\"lang\")) {\n      _this.ArtyomVoice = _this.getVoice(config.lang);\n      _this.ArtyomProperties.lang = config.lang;\n    }\n    if (config.hasOwnProperty(\"continuous\")) {\n      if (config.continuous) {\n        this.ArtyomProperties.continuous = true;\n        this.ArtyomFlags.restartRecognition = true;\n      } else {\n        this.ArtyomProperties.continuous = false;\n        this.ArtyomFlags.restartRecognition = false;\n      }\n    }\n    if (config.hasOwnProperty(\"speed\")) {\n      this.ArtyomProperties.speed = config.speed;\n    }\n    if (config.hasOwnProperty(\"soundex\")) {\n      this.ArtyomProperties.soundex = config.soundex;\n    }\n    if (config.hasOwnProperty(\"executionKeyword\")) {\n      this.ArtyomProperties.executionKeyword = config.executionKeyword;\n    }\n    if (config.hasOwnProperty(\"obeyKeyword\")) {\n      this.ArtyomProperties.obeyKeyword = config.obeyKeyword;\n    }\n    if (config.hasOwnProperty(\"volume\")) {\n      this.ArtyomProperties.volume = config.volume;\n    }\n    if (config.hasOwnProperty(\"listen\")) {\n      this.ArtyomProperties.listen = config.listen;\n    }\n    if (config.hasOwnProperty(\"name\")) {\n      this.ArtyomProperties.name = config.name;\n    }\n    if (config.hasOwnProperty(\"debug\")) {\n      this.ArtyomProperties.debug = config.debug;\n    } else {\n      console.warn(\"The initialization doesn't provide how the debug mode should be handled. Is recommendable to set this value either to true or false.\");\n    }\n    if (config.mode) {\n      this.ArtyomProperties.mode = config.mode;\n    }\n    if (this.ArtyomProperties.listen === true) {\n      return new Promise(function (resolve, reject) {\n        _this.hey(resolve, reject);\n      });\n    }\n    return Promise.resolve(true);\n  };\n  /**\r\n   * Add commands like an artisan. If you use artyom for simple tasks\r\n   * then probably you don't like to write a lot to achieve it.\r\n   *\r\n   * Use the artisan syntax to write less, but with the same accuracy.\r\n   *\r\n   * @disclaimer Not a promise-based implementation, just syntax.\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.on = function (indexes, smart) {\n    var _this = this;\n    return {\n      then: function (action) {\n        var command = {\n          indexes: indexes,\n          action: action\n        };\n        if (smart) {\n          command.smart = true;\n        }\n        _this.addCommands(command);\n      }\n    };\n  };\n  /**\r\n   * Generates an artyom event with the designed name\r\n   *\r\n   * @param {type} name\r\n   * @returns {undefined}\r\n   */\n  Artyom.prototype.triggerEvent = function (name, param) {\n    var event = new CustomEvent(name, {\n      'detail': param\n    });\n    document.dispatchEvent(event);\n    return event;\n  };\n  /**\r\n   * Repeats the last sentence that artyom said.\r\n   * Useful in noisy environments.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/repeatlastsay\r\n   * @param {Boolean} returnObject If set to true, an object with the text and the timestamp when was executed will be returned.\r\n   * @returns {Object}\r\n   */\n  Artyom.prototype.repeatLastSay = function (returnObject) {\n    var last = this.ArtyomProperties.helpers.lastSay;\n    if (returnObject) {\n      return last;\n    } else {\n      if (last != null) {\n        this.say(last.text);\n      }\n    }\n  };\n  /**\r\n   * Create a listener when an artyom action is called.\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/when\r\n   * @param {type} event\r\n   * @param {type} action\r\n   * @returns {undefined}\r\n   */\n  Artyom.prototype.when = function (event, action) {\n    return document.addEventListener(event, function (e) {\n      action(e[\"detail\"]);\n    }, false);\n  };\n  /**\r\n   * Process the recognized text if artyom is active in remote mode.\r\n   *\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.remoteProcessorService = function (action) {\n    this.ArtyomProperties.helpers.remoteProcessorHandler = action;\n    return true;\n  };\n  /**\r\n   * Verify if there's a voice available for a language using its language code identifier.\r\n   *\r\n   * @return {Boolean}\r\n   */\n  Artyom.prototype.voiceAvailable = function (languageCode) {\n    return typeof this.getVoice(languageCode) !== \"undefined\";\n  };\n  /**\r\n   * A boolean to check if artyom is obeying commands or not.\r\n   *\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.isObeying = function () {\n    return this.ArtyomProperties.obeying;\n  };\n  /**\r\n   * Allow artyom to obey commands again.\r\n   *\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.obey = function () {\n    return this.ArtyomProperties.obeying = true;\n  };\n  /**\r\n   * Pause the processing of commands. Artyom still listening in the background and it can be resumed after a couple of seconds.\r\n   *\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.dontObey = function () {\n    return this.ArtyomProperties.obeying = false;\n  };\n  /**\r\n   * This function returns a boolean according to the speechSynthesis status\r\n   * if artyom is speaking, will return true.\r\n   *\r\n   * Note: This is not a feature of speechSynthesis, therefore this value hangs on\r\n   * the fiability of the onStart and onEnd events of the speechSynthesis\r\n   *\r\n   * @since 0.9.3\r\n   * @summary Returns true if speechSynthesis is active\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.isSpeaking = function () {\n    return this.ArtyomProperties.speaking;\n  };\n  /**\r\n   * This function returns a boolean according to the SpeechRecognition status\r\n   * if artyom is listening, will return true.\r\n   *\r\n   * Note: This is not a feature of SpeechRecognition, therefore this value hangs on\r\n   * the fiability of the onStart and onEnd events of the SpeechRecognition\r\n   *\r\n   * @since 0.9.3\r\n   * @summary Returns true if SpeechRecognition is active\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.isRecognizing = function () {\n    return this.ArtyomProperties.recognizing;\n  };\n  /**\r\n   * This function will return the webkitSpeechRecognition object used by artyom\r\n   * retrieve it only to debug on it or get some values, do not make changes directly\r\n   *\r\n   * @readonly\r\n   * @since 0.9.2\r\n   * @summary Retrieve the native webkitSpeechRecognition object\r\n   * @returns {Object webkitSpeechRecognition}\r\n   */\n  Artyom.prototype.getNativeApi = function () {\n    return this.ArtyomWebkitSpeechRecognition;\n  };\n  /**\r\n   * Returns the SpeechSynthesisUtterance garbageobjects.\r\n   *\r\n   * @returns {Array}\r\n   */\n  Artyom.prototype.getGarbageCollection = function () {\n    return this.ArtyomGarbageCollection;\n  };\n  /**\r\n   *  Retrieve a single voice of the browser by it's language code.\r\n   *  It will return the first voice available for the language on every device.\r\n   *\r\n   * @param languageCode\r\n   */\n  Artyom.prototype.getVoice = function (languageCode) {\n    var voiceIdentifiersArray = this.ArtyomVoicesIdentifiers[languageCode];\n    if (!voiceIdentifiersArray) {\n      console.warn(\"The providen language \" + languageCode + \" isn't available, using English Great britain as default\");\n      voiceIdentifiersArray = this.ArtyomVoicesIdentifiers[\"en-GB\"];\n    }\n    var voice = undefined;\n    var voices = speechSynthesis.getVoices();\n    var voicesLength = voiceIdentifiersArray.length;\n    var _loop_1 = function (i) {\n      var foundVoice = voices.filter(function (voice) {\n        return voice.name == voiceIdentifiersArray[i] || voice.lang == voiceIdentifiersArray[i];\n      })[0];\n      if (foundVoice) {\n        voice = foundVoice;\n        return \"break\";\n      }\n    };\n    for (var i = 0; i < voicesLength; i++) {\n      var state_1 = _loop_1(i);\n      if (state_1 === \"break\") break;\n    }\n    return voice;\n  };\n  /**\r\n   * Artyom provide an easy way to create a\r\n   * dictation for your user.\r\n   *\r\n   * Just create an instance and start and stop when you want\r\n   *\r\n   * @returns Object | newDictation\r\n   */\n  Artyom.prototype.newDictation = function (settings) {\n    var _this = this;\n    if (!_this.recognizingSupported()) {\n      console.error(\"SpeechRecognition is not supported in this browser\");\n      return false;\n    }\n    var dictado = new window.webkitSpeechRecognition();\n    dictado.continuous = true;\n    dictado.interimResults = true;\n    dictado.lang = _this.ArtyomProperties.lang;\n    dictado.onresult = function (event) {\n      var temporal = \"\";\n      var interim = \"\";\n      for (var i = 0; i < event.results.length; ++i) {\n        if (event.results[i].isFinal) {\n          temporal += event.results[i][0].transcript;\n        } else {\n          interim += event.results[i][0].transcript;\n        }\n      }\n      if (settings.onResult) {\n        settings.onResult(interim, temporal);\n      }\n    };\n    return new function () {\n      var dictation = dictado;\n      var flagStartCallback = true;\n      var flagRestart = false;\n      this.onError = null;\n      this.start = function () {\n        if (settings.continuous === true) {\n          flagRestart = true;\n        }\n        dictation.onstart = function () {\n          if (typeof settings.onStart === \"function\") {\n            if (flagStartCallback === true) {\n              settings.onStart();\n            }\n          }\n        };\n        dictation.onend = function () {\n          if (flagRestart === true) {\n            flagStartCallback = false;\n            dictation.start();\n          } else {\n            flagStartCallback = true;\n            if (typeof settings.onEnd === \"function\") {\n              settings.onEnd();\n            }\n          }\n        };\n        dictation.start();\n      };\n      this.stop = function () {\n        flagRestart = false;\n        dictation.stop();\n      };\n      if (typeof settings.onError === \"function\") {\n        dictation.onerror = settings.onError;\n      }\n    }();\n  };\n  /**\r\n   * A voice prompt will be executed.\r\n   *\r\n   * @param {type} config\r\n   * @returns {undefined}\r\n   */\n  Artyom.prototype.newPrompt = function (config) {\n    if (typeof config !== \"object\") {\n      console.error(\"Expected the prompt configuration.\");\n    }\n    var copyActualCommands = Object.assign([], this.ArtyomCommands);\n    var _this = this;\n    this.emptyCommands();\n    var promptCommand = {\n      description: \"Setting the artyom commands only for the prompt. The commands will be restored after the prompt finishes\",\n      indexes: config.options,\n      action: function (i, wildcard) {\n        _this.ArtyomCommands = copyActualCommands;\n        var toExe = config.onMatch(i, wildcard);\n        if (typeof toExe !== \"function\") {\n          console.error(\"onMatch function expects a returning function to be executed\");\n          return;\n        }\n        toExe();\n      }\n    };\n    if (config.smart) {\n      promptCommand.smart = true;\n    }\n    this.addCommands(promptCommand);\n    if (typeof config.beforePrompt !== \"undefined\") {\n      config.beforePrompt();\n    }\n    var callbacks = {\n      onStart: function () {\n        if (typeof config.onStartPrompt !== \"undefined\") {\n          config.onStartPrompt();\n        }\n      },\n      onEnd: function () {\n        if (typeof config.onEndPrompt !== \"undefined\") {\n          config.onEndPrompt();\n        }\n      }\n    };\n    this.say(config.question, callbacks);\n  };\n  /**\r\n   * Says a random quote and returns it's object\r\n   *\r\n   * @param {type} data\r\n   * @returns {object}\r\n   */\n  Artyom.prototype.sayRandom = function (data) {\n    if (data instanceof Array) {\n      var index = Math.floor(Math.random() * data.length);\n      this.say(data[index]);\n      return {\n        text: data[index],\n        index: index\n      };\n    } else {\n      console.error(\"Random quotes must be in an array !\");\n      return null;\n    }\n  };\n  /**\r\n   * Shortcut method to enable the artyom debug on the fly.\r\n   *\r\n   * @returns {Array}\r\n   */\n  Artyom.prototype.setDebug = function (status) {\n    if (status) {\n      return this.ArtyomProperties.debug = true;\n    } else {\n      return this.ArtyomProperties.debug = false;\n    }\n  };\n  /**\r\n   * Simulate a voice command via JS\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/simulateinstruction\r\n   * @param {type} sentence\r\n   * @returns {undefined}\r\n   */\n  Artyom.prototype.simulateInstruction = function (sentence) {\n    var _this = this;\n    if (!sentence || typeof sentence !== \"string\") {\n      console.warn(\"Cannot execute a non string command\");\n      return false;\n    }\n    var foundCommand = _this.execute(sentence); //Command founded object\n    if (typeof foundCommand === \"object\") {\n      if (foundCommand.instruction) {\n        if (foundCommand.instruction.smart) {\n          _this.debug('Smart command matches with simulation, executing', \"info\");\n          foundCommand.instruction.action(foundCommand.index, foundCommand.wildcard.item, foundCommand.wildcard.full);\n        } else {\n          _this.debug('Command matches with simulation, executing', \"info\");\n          foundCommand.instruction.action(foundCommand.index); //Execute Normal command\n        }\n        return true;\n      }\n    } else {\n      console.warn(\"No command founded trying with \" + sentence);\n      return false;\n    }\n  };\n  /**\r\n   * Javascript implementation of the soundex algorithm.\r\n   * @see https://gist.github.com/shawndumas/1262659\r\n   * @returns {String}\r\n   */\n  Artyom.prototype.soundex = function (s) {\n    var a = s.toLowerCase().split('');\n    var f = a.shift();\n    var r = '';\n    var codes = {\n      a: \"\",\n      e: \"\",\n      i: \"\",\n      o: \"\",\n      u: \"\",\n      b: 1,\n      f: 1,\n      p: 1,\n      v: 1,\n      c: 2,\n      g: 2,\n      j: 2,\n      k: 2,\n      q: 2,\n      s: 2,\n      x: 2,\n      z: 2,\n      d: 3,\n      t: 3,\n      l: 4,\n      m: 5,\n      n: 5,\n      r: 6\n    };\n    r = f + a.map(function (v, i, a) {\n      return codes[v];\n    }).filter(function (v, i, a) {\n      return i === 0 ? v !== codes[f] : v !== a[i - 1];\n    }).join('');\n    return (r + '000').slice(0, 4).toUpperCase();\n  };\n  /**\r\n   * Splits a string into an array of strings with a limited size (chunk_length).\r\n   *\r\n   * @param {String} input text to split into chunks\r\n   * @param {Integer} chunk_length limit of characters in every chunk\r\n   */\n  Artyom.prototype.splitStringByChunks = function (input, chunk_length) {\n    input = input || \"\";\n    chunk_length = chunk_length || 100;\n    var curr = chunk_length;\n    var prev = 0;\n    var output = [];\n    while (input[curr]) {\n      if (input[curr++] == ' ') {\n        output.push(input.substring(prev, curr));\n        prev = curr;\n        curr += chunk_length;\n      }\n    }\n    output.push(input.substr(prev));\n    return output;\n  };\n  /**\r\n   * Allows to retrieve the recognized spoken text of artyom\r\n   * and do something with it everytime something is recognized\r\n   *\r\n   * @param {String} action\r\n   * @returns {Boolean}\r\n   */\n  Artyom.prototype.redirectRecognizedTextOutput = function (action) {\n    if (typeof action != \"function\") {\n      console.warn(\"Expected function to handle the recognized text ...\");\n      return false;\n    }\n    this.ArtyomProperties.helpers.redirectRecognizedTextOutput = action;\n    return true;\n  };\n  /**\r\n   * Restarts artyom with the initial configuration.\r\n   *\r\n   * @param configuration\r\n   */\n  Artyom.prototype.restart = function () {\n    var _this = this;\n    var _copyInit = _this.ArtyomProperties;\n    return new Promise(function (resolve, reject) {\n      _this.fatality().then(function () {\n        _this.initialize(_copyInit).then(resolve, reject);\n      });\n    });\n  };\n  /**\r\n   * Talks a text according to the given parameters.\r\n   *\r\n   * @private This function is only to be used internally.\r\n   * @param {String} text Text to be spoken\r\n   * @param {Int} actualChunk Number of chunk of the\r\n   * @param {Int} totalChunks\r\n   * @returns {undefined}\r\n   */\n  Artyom.prototype.talk = function (text, actualChunk, totalChunks, callbacks) {\n    var _this = this;\n    var msg = new SpeechSynthesisUtterance();\n    msg.text = text;\n    msg.volume = this.ArtyomProperties.volume;\n    msg.rate = this.ArtyomProperties.speed;\n    // Select the voice according to the selected\n    var availableVoice = _this.getVoice(_this.ArtyomProperties.lang);\n    if (callbacks) {\n      // If the language to speak has been forced, use it\n      if (callbacks.hasOwnProperty(\"lang\")) {\n        availableVoice = _this.getVoice(callbacks.lang);\n      }\n    }\n    // If is a mobile device, provide only the language code in the lang property i.e \"es_ES\"\n    if (this.Device.isMobile) {\n      // Try to set the voice only if exists, otherwise don't use anything to use the native voice\n      if (availableVoice) {\n        msg.lang = availableVoice.lang;\n      }\n      // If browser provide the entire object\n    } else {\n      msg.voice = availableVoice;\n    }\n    // If is first text chunk (onStart)\n    if (actualChunk == 1) {\n      msg.addEventListener('start', function () {\n        // Set artyom is talking\n        _this.ArtyomProperties.speaking = true;\n        // Trigger the onSpeechSynthesisStart event\n        _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_START);\n        _this.triggerEvent(_this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_START);\n        // Trigger the onStart callback if exists\n        if (callbacks) {\n          if (typeof callbacks.onStart == \"function\") {\n            callbacks.onStart.call(msg);\n          }\n        }\n      });\n    }\n    // If is final text chunk (onEnd)\n    if (actualChunk >= totalChunks) {\n      msg.addEventListener('end', function () {\n        // Set artyom is talking\n        _this.ArtyomProperties.speaking = false;\n        // Trigger the onSpeechSynthesisEnd event\n        _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_END);\n        _this.triggerEvent(_this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_END);\n        // Trigger the onEnd callback if exists.\n        if (callbacks) {\n          if (typeof callbacks.onEnd == \"function\") {\n            callbacks.onEnd.call(msg);\n          }\n        }\n      });\n    }\n    // Notice how many chunks were processed for the given text.\n    this.debug(actualChunk + \" text chunk processed succesfully out of \" + totalChunks);\n    // Important : Save the SpeechSynthesisUtterance object in memory, otherwise it will get lost\n    this.ArtyomGarbageCollection.push(msg);\n    window.speechSynthesis.speak(msg);\n  };\n  /**\r\n   * Process the given text into chunks and execute the private function talk\r\n   *\r\n   * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/say\r\n   * @param {String} message Text to be spoken\r\n   * @param {Object} callbacks\r\n   * @returns {undefined}\r\n   */\n  Artyom.prototype.say = function (message, callbacks) {\n    var artyom_say_max_chunk_length = 115;\n    var _this = this;\n    var definitive = [];\n    if (this.speechSupported()) {\n      if (typeof message != 'string') {\n        return console.warn(\"Artyom expects a string to speak \" + typeof message + \" given\");\n      }\n      if (!message.length) {\n        return console.warn(\"Cannot speak empty string\");\n      }\n      // If the providen text is long, proceed to split it\n      if (message.length > artyom_say_max_chunk_length) {\n        // Split the given text by pause reading characters [\",\",\":\",\";\",\". \"] to provide a natural reading feeling.\n        var naturalReading = message.split(/,|:|\\. |;/);\n        naturalReading.forEach(function (chunk, index) {\n          // If the sentence is too long and could block the API, split it to prevent any errors.\n          if (chunk.length > artyom_say_max_chunk_length) {\n            // Process the providen string into strings (withing an array) of maximum aprox. 115 characters to prevent any error with the API.\n            var temp_processed = _this.splitStringByChunks(chunk, artyom_say_max_chunk_length);\n            // Add items of the processed sentence into the definitive chunk.\n            definitive.push.apply(definitive, temp_processed);\n          } else {\n            // Otherwise just add the sentence to being spoken.\n            definitive.push(chunk);\n          }\n        });\n      } else {\n        definitive.push(message);\n      }\n      // Clean any empty item in array\n      definitive = definitive.filter(function (e) {\n        return e;\n      });\n      // Finally proceed to talk the chunks and assign the callbacks.\n      definitive.forEach(function (chunk, index) {\n        var numberOfChunk = index + 1;\n        if (chunk) {\n          _this.talk(chunk, numberOfChunk, definitive.length, callbacks);\n        }\n      });\n      // Save the spoken text into the lastSay object of artyom\n      _this.ArtyomProperties.helpers.lastSay = {\n        text: message,\n        date: new Date()\n      };\n    }\n  };\n  return Artyom;\n}();\nexports.default = Artyom;","map":null,"metadata":{},"sourceType":"script"}